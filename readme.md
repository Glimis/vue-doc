vue 的创始理念是`简单`

从`vue0.1/vue1`能明显的感受到这种态度,怎么方便怎么来

实现,就跟能想象到的一样,没有太多的概念

而react的创始理念是`不关注`并高效

## 不关注
对于jsp时期,通过table按钮进行删除,需要动态添改变table的内容

最早期的做法是删除,调用ajax后,`直接刷新页面`

直接刷新页面就是`不关注`,他复用了页面初始化的逻辑

类似的情况包括echart,hchart,jq组件,在我懒得更新的时候,我可以尝试修改`config`,并重新创建实例,达到刷新的目的

## 高效
无论是刷新页面还是组件重新实例化,都是低效的

最高效的方式一定是直接定位到具体的事件,而`直接定位`就是`关心`

## 中间层 - component
不关心的核心概念就是刷新中间层`component`,也就是组件 【总不能刷新整个页面吧】

类似于`$.combox(el,config)`,在减少下拉属性后,修改config,在此调用`$.combox(el,config)`

区别在于,当`config`改变后自动修改,这也是`mvvm`与`mvc`最大的区别,即`主动触发`与`被动触发`

### 高效刷新 - vdom
component整个刷新依然是低效的,最高效的方式是比较不同,将全局刷新还原为关注细节的方式

有一种从结果逆推的方式,即生成config改变后的html,然后比较不同 【算法 - 比较字符串的不同】

生成不同变化的函数,然后执行函数即可

我们一般说的vdom,干的就是这事,vdom与不渲染的dom表现一致 【当然他有更多的拓展性,比如自定义标签】

注:所谓的vdom更加高效,是跟全局刷新对比的,跟`关注型`完全没有可比性

### 被动触发 - 依赖收集
config被修改了如何处罚?`Object.defineProperties`,那触发后执行的是什么?

对于vue0.1,执行的是指令的变化,甚至是具体dom内容的改变 --》 vue0.1源码

而对于react的理念,触发的就是`component`的刷新

这里的问题是,如果一个组件,同一时间,两个属性都修改了,如何保证刷新一次?

几个机制,就是依赖收集


## vue2 面向react 改变
上诉说的概念,直接贴到vue2中也行

因为vue2的核心是`跨平台`与`通用`

跨平台需要不依赖`view`,也就是vm不能再直接关联view   【vue 提供了 两种view关联】

需要一种解耦,而这种解耦的方式,最终只想了vdom

简单地说,实现的概念上有了很大的重复   【虽然出发点不一样】
